{"pageProps":{"title":"InteractiveQuery / FilterDSL","docs":{"handwritten":[{"replace":"FilterDSL.Type","src":"FilterDSL-Type.md","frontmatter":{},"sections":[{"stub":"filterdsl.type","title":"FilterDSL.Type","level":3,"content":"<p>Enum object containting the node types </p><table class=\"table table-bordered table-hover\"><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>FIELD</td><td>field / column reference</td></tr><tr><td>CONDITION</td><td>Condition node</td></tr><tr><td>VALUE</td><td>Value node</td></tr><tr><td>VALUES</td><td>Values node (for .in())</td></tr><tr><td>OPERATION</td><td>field operation</td></tr><tr><td>COMPONENT</td><td>component marker</td></tr></tbody></table>"}],"toc":{"level":3,"name":"filterdsl.type","title":"FilterDSL.Type","headings":[]}}],"docs":{"compareConditions":{"name":"compareConditions","source":"src/util/compareConditions.js","description":{"description":"Does a deep-comparison between two conditions","tags":[{"title":"category","description":"iquery"},{"title":"param","description":"condition node A","type":{"type":"NameExpression","name":"ConditionNode"},"name":"a"},{"title":"param","description":"condition node B","type":{"type":"NameExpression","name":"ConditionNode"},"name":"b"},{"title":"param","description":"compare the value of value nodes (default = false)","type":{"type":"NameExpression","name":"boolean"},"name":"compareValueNodes"},{"title":"return","description":"true if the conditions are equal (ignoring values)","type":{"type":"NameExpression","name":"boolean"}}]},"group":"FUNCTION","reactDocGen":null,"start":16,"end":70,"category":"iquery","link":"iquery#compareConditions"},"createMockedQuery":{"name":"createMockedQuery","source":"src/util/createMockedQuery.js","description":{"description":"Creates a mocked query that returns a single constant result.\n\nIf you need filtering or pagination on your mock, use createFilteredMockQuery","tags":[{"title":"category","description":"iquery"},{"title":"param","description":"wire format","type":null,"name":"format"},{"title":"param","description":"iQuery container type","type":{"type":"NameExpression","name":"String"},"name":"type"},{"title":"param","description":"constant iQuery result to return from the mocked query or function producing a result from given variables","type":{"type":"UnionType","elements":[{"type":"NameExpression","name":"Object"},{"type":"NameExpression","name":"function"}]},"name":"payload"},{"title":"return","description":"mocked query object.","type":{"type":"NameExpression","name":"GraphQLQuery"}}]},"group":"FUNCTION","reactDocGen":null,"start":18,"end":66,"category":"iquery","link":"iquery#createMockedQuery"},"evaluateMemoryQuery":{"name":"evaluateMemoryQuery","source":"src/util/evaluateMemoryQuery.js","description":{"description":"Filters a given cached iQuery document according to the give query config object.","tags":[{"title":"category","description":"iquery"},{"title":"param","description":"WireFormat instance","type":null,"name":"format"},{"title":"param","description":"cached iQuery document containing all data","type":null,"name":"cachedDocument"},{"title":"param","description":"QueryConfig instance","type":null,"name":"queryConfig"}]},"group":"FUNCTION","reactDocGen":null,"start":122,"end":171,"category":"iquery","link":"iquery#evaluateMemoryQuery"},"FieldResolver":{"name":"FieldResolver","source":"src/util/filterTransformer.js","description":{"description":"Default field resolver implementation for js object graphs.","tags":[{"title":"category","description":"iquery"},{"title":"param","description":"initial object","type":{"type":"NameExpression","name":"Object"},"name":"current"},{"title":"constructor","description":null,"name":null}]},"group":"UTIL","reactDocGen":null,"start":540,"end":555,"category":"iquery","link":"iquery#FieldResolver"},"FilterDSL":{"name":"FilterDSL","source":"src/FilterDSL.js","description":{"description":"The automaton filter DSL creates object graphs representations of filter expressions that can be evaluated as SQL, on\nJava objects and on JavaScript objects.","tags":[{"title":"category","description":"iquery"}]},"group":"UTIL","reactDocGen":null,"start":585,"end":693,"members":[{"type":"Identifier","name":"not","description":{"description":"Logical not condition.","tags":[{"title":"param","description":null,"type":{"type":"NameExpression","name":"ConditionNode"},"name":"operand"},{"title":"return","description":"negated condition","type":{"type":"NameExpression","name":"ConditionNode"}}]}},{"type":"Identifier","name":"or","description":{"description":"Logical or condition. Will remove null conditions","tags":[{"title":"param","description":null,"type":{"type":"RestType","expression":{"type":"NameExpression","name":"ConditionNode"}},"name":"operands"},{"title":"return","description":"ORed condition","type":{"type":"NameExpression","name":"ConditionNode"}}]}},{"type":"Identifier","name":"and","description":{"description":"Logical or condition. Will ignore falsy operands.","tags":[{"title":"param","description":null,"type":{"type":"RestType","expression":{"type":"NameExpression","name":"ConditionNode"}},"name":"operands"},{"title":"return","description":"ORed condition","type":{"type":"NameExpression","name":"ConditionNode"}}]}},{"type":"Identifier","name":"condition","description":{"description":"General Condition node. Useful for programmatically instantiating conditions. Not needed for fluent style conditions.","tags":[{"title":"param","description":"condition name","type":{"type":"NameExpression","name":"String"},"name":"name"},{"title":"param","description":"operands","type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Array"},"applications":[{"type":"NameExpression","name":"ConditionNode"}]},"name":"operands"},{"title":"return","description":null,"type":{"type":"NameExpression","name":"ConditionNode"}}]}},{"type":"Identifier","name":"field","description":{"description":"Field / column reference.","tags":[{"title":"param","description":"field name (e.g. \"name\", \"owner.name\")","type":{"type":"NameExpression","name":"String"},"name":"name"},{"title":"return","description":null,"type":{"type":"NameExpression","name":"Field"}}]}},{"type":"Identifier","name":"component","description":{"description":"Component condition node. These nodes are just marker for which part of the condition originated from which component\nLogically they are evaluated as the condition they wrap.","tags":[{"title":"param","description":"component id","type":{"type":"NameExpression","name":"String"},"name":"id"},{"title":"param","description":"actual condition for component","type":{"type":"NameExpression","name":"ConditionNode"},"name":"condition"},{"title":"return","description":null,"type":{"type":"NameExpression","name":"ConditionNode"}}]}},{"type":"Identifier","name":"value","description":{"description":"Creates a new value node","tags":[{"title":"param","description":"scalar value of appropriate type","type":{"type":"NameExpression","name":"Object"},"name":"value"}]}},{"type":"Identifier","name":"values","description":{"description":"Creates a new values node that encapsulates a collection of scalar values (for e.g. the IN operator)","tags":[{"title":"param","description":"scalar type name","type":{"type":"NameExpression","name":"String"},"name":"type"},{"title":"param","description":"var args of scalar value of appropriate type","type":{"type":"NameExpression","name":"Object"},"name":"values"},{"title":"return","description":"values node","type":{"type":"NameExpression","name":"Values"}}]}},{"type":"Identifier","name":"getConditionArgCount","description":{"description":"Returns the number of expected arguments for the condition with the given name.","tags":[{"title":"param","description":"condition name","type":{"type":"NameExpression","name":"String"},"name":"name"},{"title":"return","description":"number of value arguments expected","type":{"type":"NameExpression","name":"number"}}]}},{"type":"Identifier","name":"isLogicalCondition","description":{"description":"Returns true if the given condition node is either a logical and or a logical or condition.","tags":[{"title":"param","description":"node","type":{"type":"NameExpression","name":"Object"},"name":"node"},{"title":"return","description":"true if the node is either an \"and\" or an \"or\"","type":{"type":"NameExpression","name":"boolean"}}]}},{"type":"Identifier","name":"findComponentNode","description":{"description":"Finds a component node with the given id.","tags":[{"title":"param","description":"condition structure root","type":{"type":"NameExpression","name":"Object"},"name":"conditionNode"},{"title":"param","description":"component id","type":{"type":"NameExpression","name":"String"},"name":"id"},{"title":"return","description":"component node or `null`","type":{"type":"UnionType","elements":[{"type":"NameExpression","name":"Object"},{"type":"NullLiteral"}]}}]}},{"type":"Identifier","name":"Type","description":{"description":"Node type constants.","tags":[{"title":"type","description":null,"type":{"type":"RecordType","fields":[{"type":"FieldType","key":"OPERATION","value":{"type":"NameExpression","name":"string"}},{"type":"FieldType","key":"FIELD","value":{"type":"NameExpression","name":"string"}},{"type":"FieldType","key":"CONDITION","value":{"type":"NameExpression","name":"string"}},{"type":"FieldType","key":"COMPONENT","value":{"type":"NameExpression","name":"string"}},{"type":"FieldType","key":"VALUE","value":{"type":"NameExpression","name":"string"}},{"type":"FieldType","key":"VALUES","value":{"type":"NameExpression","name":"string"}}]}}]}}],"category":"iquery","link":"iquery#FilterDSL"},"filterTransformer":{"name":"filterTransformer","source":"src/util/filterTransformer.js","description":{"description":"Filter transformer function that transforms a condition as JSON object to an executable JS function.","tags":[{"title":"category","description":"iquery"},{"title":"param","description":"JSON condition map","type":{"type":"NameExpression","name":"Object"},"name":"condition"},{"title":"param","description":"function that creates a field resolver function for a given field name\n                                         ( name => { return () => f(name) } )","type":{"type":"NameExpression","name":"Function"},"name":"resolverFactory"}]},"group":"FUNCTION","reactDocGen":null,"start":513,"end":529,"category":"iquery","link":"iquery#filterTransformer"},"getFirstValue":{"name":"getFirstValue","source":"src/model/InteractiveQuery.js","description":{"description":"Returns the first value from an object.","tags":[{"title":"category","description":"iquery"},{"title":"param","description":"js object","type":{"type":"NameExpression","name":"object"},"name":"m"},{"title":"returns","description":null,"type":{"type":"AllLiteral"}}]},"group":"FUNCTION","reactDocGen":null,"start":20,"end":30,"category":"iquery","link":"iquery#getFirstValue"},"InteractiveQuery":{"name":"InteractiveQuery","source":"src/model/InteractiveQuery.js","description":{"description":"Client-side implementation of the InteractiveQuery mechanism. Meant to be registered for all concrete types created\nfor de.quinscape.automaton.model.data.InteractiveQuery","tags":[{"title":"category","description":"iquery"}]},"group":"UTIL","reactDocGen":null,"start":88,"end":290,"members":[{"type":"ClassProperty","name":"rows","description":{"description":"Current result rows of the base type","tags":[]},"decorators":["observable"]},{"type":"ClassProperty","name":"queryConfig","description":{"description":"Query config object used to create this query","tags":[]},"decorators":["observable"]},{"type":"ClassProperty","name":"columnStates","description":{"description":"Array of column states for this query","tags":[]},"decorators":["observable"]},{"type":"ClassProperty","name":"rowCount","description":{"description":"Total number of rows available for pagination","tags":[{"title":"type","description":null,"type":{"type":"NameExpression","name":"number"}}]},"decorators":["observable"]},{"type":"ClassMethod","name":"setQueryConfig","description":{"description":"Set the new queryConfig without mobx printing warnings.\n\nThis is supposed to be only called from the inside.","tags":[{"title":"param","description":"the new query configuration","type":{"type":"NameExpression","name":"Object"},"name":"config"}]},"decorators":["action"]},{"type":"ClassMethod","name":"update","description":{"description":"Updates the current iQuery base on a new query config. The given query config is merged with the current config\nso you only need to define the changes.\n\nExamples:\n\n```js\n// page to second page\niQuery.update({offset: 10})\n\n// sorty by name descending\niQuery.update({\n    sortFields: [ \"!name\" ]\n})\n```","tags":[{"title":"param","description":"query config structure (see de.quinscape.automaton.model.data.QueryConfig)","type":{"type":"NameExpression","name":"Object"},"name":"queryConfig"},{"title":"return","description":null,"type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Promise"},"applications":[{"type":"UnionType","elements":[{"type":"AllLiteral"},{"type":"NameExpression","name":"never"}]}]}}]},"decorators":["action"]},{"type":"ClassMethod","name":"updateCondition","description":{"description":"Updates a component condition in the current query config state.\n\nIf no component node is found, the current condition if present will be ANDed with the component condition","tags":[{"title":"param","description":"condition node","type":{"type":"NameExpression","name":"Object"},"name":"componentCondition"}]},"decorators":[]},{"type":"ClassMethod","name":"separate","description":{"description":"Extracts a new independent iQuery object with a new Query containing only the selections for that iQuery.","tags":[{"title":"param","description":"multi iQuery result object","type":{"type":"NameExpression","name":"Object"},"name":"result"},{"title":"param","description":"variable name of this query in the original query","type":{"type":"NameExpression","name":"String"},"name":"varName"}]},"decorators":[]}],"category":"iquery","link":"iquery#InteractiveQuery"},"updateComponentCondition":{"name":"updateComponentCondition","source":"src/util/updateComponentCondition.js","description":{"description":"Updates a logical condition composed of component conditions with a new condition for one of the components.","tags":[{"title":"category","description":"iquery"},{"title":"param","description":"logical condition composed of component conditions.","type":{"type":"NameExpression","name":"Object"},"name":"compositeCondition"},{"title":"param","description":"new component condition","type":{"type":"NameExpression","name":"Object"},"name":"componentCondition"}]},"group":"FUNCTION","reactDocGen":null,"start":83,"end":190,"category":"iquery","link":"iquery#updateComponentCondition"}},"utils":["FieldResolver","FilterDSL","InteractiveQuery"],"functions":["compareConditions","createMockedQuery","evaluateMemoryQuery","filterTransformer","getFirstValue","updateComponentCondition"]}},"__N_SSG":true}